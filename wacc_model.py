import numpy as np
import warnings
import xarray as xr
import time
import csv
import os
import io
import cartopy.crs as ccrs
import matplotlib.colors as colors
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from scipy.interpolate import interp1d
import cartopy.feature as cfeature
from matplotlib.patches import Patch
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
import math
import sys
import pandas as pd
import os 
import regionmask
import warnings
from joblib import Parallel, delayed
from scipy.optimize import minimize, minimize_scalar
from geodata_v2 import Global_Data
from CostofCapitalAnalyser import CoCModel
from postprocessor_v1 import PostProcessor
warnings.filterwarnings("ignore")

class WaccEstimator:
    def __init__(self, data_path, country_grids, electricity_prices, solar_results, wind_results, capex_mapping, generation_data, crp_data, irena_waccs, aures_waccs, country_codes, aures_diacore, OECD_IR, IMF_IR, GDP, collated_IR, tax_data, irena_2022, rise_data, country_mapping, economic_parameters, output_folder, land_cover, land_mapping, TIAM_regions, uniform_factor, solar_cf, wind_cf):     
        """ Initialises the WaccEstimator class, which can be used to calculate the WACC required to reach a specified price on a geospatial basis
        
       
        Inputs:
        Data_path - path direction to Data inputs
        Country_grids - geospatial coding for national territories
        Electricity_Prices - Country Electricity Prices (consumer retail prices).
        Wind_results - mean wind capacity factors, generated by RENEWABLES NINJA
        Solar_results - mean solar capacity factors, generated by PV Lib
        CAPEX_mapping - Solar and Wind CAPEX costs taken from IRENA Renewable Generation Costs
        Generation_Data - Ember Yearly Generation Data for 2000-2023
        CRP_Data - Data on Country Risk Premiums, taken from Damodaran for multiple years.
        IRENA_waccs - IRENA estimates of country WACCs
        Aures_waccs - AURES data on country waccs
        Country_codes - Country coding to ISO 3 codes
        Aures_Diacore - Aures and Diacore combined data
        OECD_IR - Long term interest rate data taken from the OECD
        IMF_IR - long term interest rate data from the IMF
        GDP - GDP per capita data
        Collated_IR - Collated interest rate data from the IMF and OECD
        Tax_Data - Corporate Tax Rates for individual countries
        IRENA_2022 - Estimates from IRENA of the CoD and CoE in 2022
        RISE_Data - Regulatory Indicators for Sustainable Energy data on a yearly basis
        Country_mapping - netcdf file mapping gridcells to country codes
        Economic_Parameters - contains the assumptions and constants used by the model
        Output_folder - Output folder for results printing
        Land_Cover - netcdf file with codings for land cover categories
        Land_mapping - CSV file containing land utilisation rates for land cover categories
        TIAM_Region - Country mapping with TIAM-regions
        Uniform_Factor - value to use for a uniform global WACC analysis

        
       
       
        Classes
        CoCModel Class: Class that generates estimates of cost of capital based on IRENA data.
        Geodata: Class to generate geodata on countries, distance to shore etc.
        PostProcessor: Class to perform post processing and create plots for the manuscript.
        """
        # Read in capacity factors
        self.solar_cf = xr.open_dataset(data_path + solar_cf)['CF']
        self.wind_cf = xr.open_dataset(data_path + wind_cf)['CF']
            
        # Read in other inputs
        self.country_grids = xr.open_dataset(data_path + "country_grids.nc")
        self.electricity_prices = pd.read_csv(data_path + electricity_prices)
        self.capex_mapping = pd.read_csv(data_path + capex_mapping)
        self.TIAM_regions = pd.read_csv(data_path + TIAM_regions)
        self.country_codes = pd.read_csv(data_path + country_codes)
        
        # Create country mapping with regional details
        country_mapping_data = pd.read_csv(data_path + country_mapping)
        self.country_mapping = pd.merge(country_mapping_data, self.TIAM_regions[["Country code", "Region"]], how="left", on="Country code")
        
        # Read in costs and assumptions
        self.economic_parameters = pd.read_csv(data_path + economic_parameters)
        self.solar_opex = self.economic_parameters.loc[self.economic_parameters['Parameter'] == "solar_op_cost", "Value"].values[0]
        self.offshore_opex = self.economic_parameters.loc[self.economic_parameters['Parameter'] == "offshore_op_cost", "Value"].values[0]
        self.wind_opex = self.economic_parameters.loc[self.economic_parameters['Parameter'] == "onshore_op_cost", "Value"].values[0]
        self.lifetime = self.economic_parameters.loc[self.economic_parameters['Parameter'] == "lifetime", "Value"].values[0]
        
        # Get renewables capacity, in kWs
        self.renewables_capacity = self.economic_parameters.loc[self.economic_parameters['Parameter'] == "renewables_capacity", "Value"].values[0]
        
        
        # Initialise Cost of Capital Model
        start_time = time.time()
        self.CoCModel_class = CoCModel(data_path, generation_data, crp_data, irena_waccs, aures_waccs, country_codes, aures_diacore, OECD_IR, IMF_IR, GDP, collated_IR, electricity_prices, tax_data, irena_2022, rise_data, country_mapping)
        
        # Get predicted Cost of Capital
        self.calculated_data, self.country_wacc_mapping, self.country_wacc_lb, self.country_wacc_ub = self.CoCModel_class.estimate_future_waccs_v4("Onshore_Wind_Common_Risk_2021", "Solar_Common_Risk_2021", ['Wind_Penetration_2021', "CRP_2021", "RISE_OVERALL_2021"], ['Solar_Penetration_2021', "CRP_2021","RISE_OVERALL_2021"], "2023")
        end_time = time.time()
        total_time = end_time - start_time
        print(f"Cost of Capital Analyser took {total_time} seconds to run")
        
        # Read in solar/wind data and process
        self.solar_input = xr.open_dataset(data_path + solar_results)
        self.wind_input = xr.open_dataset(data_path + wind_results)
        self.solar_processed, self.wind_processed = self.process_inputs()
        self.wind_onshore = xr.where(np.isnan(self.solar_processed), np.nan, self.wind_processed)
        self.wind_offshore = xr.where(np.isnan(self.solar_processed), self.wind_processed, np.nan)
        
        # Get geodata
        self.geodata_class = Global_Data((data_path + "ETOPO_bathymetry.nc"),(data_path+"distance2shore.nc"), (data_path+"country_grids.nc"), self.wind_input)
        self.geodata = self.geodata_class.get_countries_in_required_resolution()
        self.offshore_mask = self.geodata_class.get_offshore_mask() 
        
        # Set uniform global factor
        self.uniform_factor = uniform_factor
        
        # Get uniform_factors from UNFCCC countries
        self.solar_pv_uf, self.onshore_uf, self.offshore_uf = self.get_unfccc_II_average()
    
        # Calculate LCOE using predicted WACCs and regional costs, alongside a uniform calculation
        self.solar_lcoe = self.calculate_lcoe_v4(self.solar_processed, technology="Solar", uniform_factor=self.solar_pv_uf)
        self.wind_lcoe = self.calculate_lcoe_v4(self.wind_onshore, technology="Onshore Wind", uniform_factor=self.onshore_uf)
        self.offshore_lcoe = self.calculate_lcoe_v4(self.wind_offshore, technology="Offshore Wind", uniform_factor=self.offshore_uf)
        
        # Merge TIAM and Country coding
        self.TIAM_regions = pd.merge(self.country_mapping, self.TIAM_regions, how="left", on="Country code") 
        
        # Initialise PostProcessor object
        self.land_cover = xr.open_dataset(data_path + land_cover)
        self.land_mapping = pd.read_csv(data_path + land_mapping)
        self.postprocessor = PostProcessor(output_folder, self.solar_lcoe, self.wind_lcoe, self.offshore_lcoe, self.CoCModel_class.GDP_data, self.land_cover, self.land_mapping, self.country_grids, self.TIAM_regions, self.country_mapping, self.solar_cf, self.wind_cf)

        
    def get_unfccc_II_average(self):
        
        # Define UNFCCC Annex II countries
        annex_ii_countries = ["AUS",  # Australia
        "AUT",  # Austria
        "BEL",  # Belgium
        "CAN",  # Canada
        "DNK",  # Denmark
        "FIN",  # Finland
        "FRA",  # France
        "DEU",  # Germany
        "GRC",  # Greece
        "ISL",  # Iceland
        "IRL",  # Ireland
        "ITA",  # Italy
        "JPN",  # Japan
        "LUX",  # Luxembourg
        "NLD",  # Netherlands
        "NZL",  # New Zealand
        "NOR",  # Norway
        "PRT",  # Portugal
        "ESP",  # Spain
        "SWE",  # Sweden
        "CHE",  # Switzerland
        "GBR",  # United Kingdom
        "USA"]   # United States of America
        
        # Extract UNFCCC countries from estimated WACCs
        extracted_countries = self.country_wacc_mapping[self.country_wacc_mapping['Country code'].isin(annex_ii_countries)]
        
        # Calculate average for onshore, offshore and solar
        onshore_average = np.nanmean(extracted_countries['onshore_wacc'])
        offshore_average = np.nanmean(extracted_countries['offshore_wacc'])
        solar_average = np.nanmean(extracted_countries['solar_pv_wacc'])
        
        return solar_average, onshore_average, offshore_average
    
    
    def process_inputs(self):
        
        # Set up latitudes and longitudes for reindexing
        latitudes= np.arange(-65, 85, 0.5)
        longitudes = np.arange(-180, 179.375, 0.625)
        
        # Reindex results and country mapping
        solar_results = self.solar_input.reindex({"latitude":latitudes, "longitude":longitudes}, method="nearest")
        wind_results = self.wind_input.reindex({"latitude":latitudes, "longitude":longitudes}, method="nearest")
        country_mapping = self.country_grids.reindex({"latitude":latitudes, "longitude": longitudes}, method="nearest")
        country_mapping['country'] = xr.where(np.isnan(country_mapping['land']), country_mapping['sea'], country_mapping['land'])
        self.land_grids = country_mapping['land']
        self.sea_grids = country_mapping['sea']
        self.country_grids = country_mapping
        
        # Reindex capacity factors
        self.solar_cf = self.solar_cf.reindex({"latitude":latitudes, "longitude":longitudes}, method="nearest")
        self.wind_cf = self.wind_cf.reindex({"latitude":latitudes, "longitude":longitudes}, method="nearest")
        
        # Get rid of results in the ocean
        solar_results = xr.where(np.isnan(country_mapping['land'])==True, np.nan, solar_results)
        
        # Calculate annual electricity production from CFs, in kWh per annum
        solar_results['electricity_production'] = solar_results['CF'] * 8760 * self.renewables_capacity
        wind_results['electricity_production'] = wind_results['CF'] * 8760 * self.renewables_capacity
        
        # Apply constraints
        solar_results['electricity_production'] = xr.where(solar_results['CF']<0.1, np.nan, solar_results['electricity_production'])
        wind_results['electricity_production'] = xr.where(wind_results['CF']<0.18, np.nan, wind_results['electricity_production'])
        
        # Store Size
        solar_results['capacity'] = self.renewables_capacity
        wind_results['capacity'] = self.renewables_capacity
        
        return solar_results, wind_results
    
    
    def calculate_discount_factor_v1(self, discount_rate):
        
        # Set sum of discount factors initially to 1
        discount_factor = 0 
        
        # Loop along all years
        for i in np.arange(1, self.lifetime + 1, 1):
            discount_factor = discount_factor + 1 * (1 + discount_rate) ** (-1 * i)
            
        return discount_factor
    
    def calculate_discount_factor_v3(self, discount_rate):
    
        # Create an array for the year indices
        years = np.arange(1, self.lifetime + 1)

        # Add a "year" dimension to the years array
        year_da = xr.DataArray(years, dims=["year"], name="year")

        # Expand discount_rate to have a "year" dimension for broadcasting
        discount_rate_expanded = discount_rate.expand_dims(year=year_da)

        # Calculate discount factors for each year and sum along the "year" dimension
        discount_factors = (1 / (1 + discount_rate_expanded) ** year_da).sum(dim="year")

        return discount_factors

    
    def get_relative_costs(self, data, countries):
    
        geodata = self.geodata['land']
        geodata = geodata.reindex({"latitude":data.latitude, "longitude":data.longitude})
        countries_in_mapping = xr.where(np.isin(geodata, countries), data['Initial_LCOE'], np.nan)
        countries_outside = xr.where(np.isin(geodata, countries), np.nan, data['Initial_LCOE'])

        mean_in = np.nanmean(countries_in_mapping)
        mean_out = np.nanmean(countries_outside)
        increase = mean_out / mean_in
        print(f"Countries not in the mapping are {(increase-1)*100:0.2f}% more expensive") 
    
    
    def get_system_costs_v2(self, benchmark_lcoe, technology):

        # Create a storage array
        system_costs = xr.full_like(self.land_grids, np.nan)

        # Extract dataframe that contains the wind and solar penetration
        renewable_penetration = self.calculated_data[['index', 'Wind_Penetration_2023', 'Solar_Penetration_2023']]
        renewable_penetration['Penetration'] = renewable_penetration['Wind_Penetration_2023'] + renewable_penetration['Solar_Penetration_2023']
        ren_penetration = renewable_penetration[['index', 'Penetration']]  
        solar_penetration = renewable_penetration[['index', 'Solar_Penetration_2023']]  
        wind_penetration = renewable_penetration[['index', 'Wind_Penetration_2023']]  

        # Loop over country indexes
        for index in np.arange(1, 251, 1): 
            # Calculate Penetration
            penetration = ren_penetration.loc[ren_penetration['index'] == index]
            wind = wind_penetration.loc[wind_penetration['index'] == index]
            solar = solar_penetration.loc[solar_penetration['index'] == index]
            
            if penetration.empty:
                system_costs = xr.where(self.land_grids == index, 0, system_costs)
                continue

            penetration_value = penetration['Penetration'].values[0] / 100
            solar_value = solar['Solar_Penetration_2023'].values[0] / 100
            wind_value = wind['Wind_Penetration_2023'].values[0] / 100

            # Calculate Balancing Costs
            balancing = 7.28 * penetration_value + 2.215
            

            # Calculate Profile Costs for wind
            if technology == "Wind":
                profile = 60.4 * wind_value + 3.35
            else:
                profile = 0 

            # Calculate system costs
            system_costs = xr.where(self.land_grids == index, profile + balancing, system_costs)

        # Calculate benchmark value
        benchmark_values = xr.where(np.isnan(system_costs), np.nan, (benchmark_lcoe - system_costs ) ) / 1000

        return benchmark_values

    def calculate_required_waccs(self, data, lcoe=None, benchmark_lcoe=None, technology=None):

        # Drop existing data
        data = data.drop_vars('Required_WACC', errors="ignore")
        
        # Convert LCOE to USD/kWh
        lcoe = lcoe / 1000

        # Extract key figures from the data
        latitudes = data.latitude.values
        longitudes = data.longitude.values
        annual_electricity_production = data['electricity_production'] # kWh for 1 MW
        initial_lcoe = data['Calculated_LCOE'] # USD/KWh for 1 MW

        # Calculate annual costs
        annual_costs = data['Calculated_OPEX'] # USD/kW/year
        capital_costs = data['Calculated_CAPEX'] # USD for 1 MW


        # Get LCOE 
        if lcoe is None:
            lcoe = self.get_system_costs_v2(benchmark_lcoe, technology)
            lcoe = xr.where(np.isnan(initial_lcoe), np.nan, lcoe)
            data['Benchmark_LCOE'] = lcoe
        else:
            data['Benchmark_LCOE'] = xr.full_like(data['Calculated_CAPEX'], lcoe)

        # Calculate discount factor at each location
        # Ensure that the denominator is not zero or negative
        valid_mask = (annual_electricity_production * lcoe - annual_costs) > 0

        # Apply the calculation only where valid
        discount_factor = xr.where(
            np.isnan(lcoe) | ~valid_mask,
            np.nan,
            capital_costs / ((annual_electricity_production * lcoe) - annual_costs)
        )

        data['Discount_Factor'] = discount_factor

        # Create array of discount factor to WACC values and round discount factor
        discount_rates = np.linspace(0, 0.24, 1001)
        discount_factors_array = self.calculate_discount_factor(discount_rates)
        xdata = discount_rates
        ydata = discount_factors_array

        # Calculate curve fit
        ylog_data = np.log(ydata)
        curve_fit = np.polyfit(xdata, ylog_data, 2)
        y = np.exp(curve_fit[2]) * np.exp(curve_fit[1]*xdata) * np.exp(curve_fit[0]*xdata**2)


        # Create interpolator
        interpolator = interp1d(ydata, xdata, kind='nearest', bounds_error=False, fill_value=(0.24, 9.99))

        # Use rounded discount factors to calculate WACC values 
        estimated_waccs = interpolator(discount_factor)*100
        estimated_waccs = xr.where(discount_factor < 0, 999, estimated_waccs)
        estimated_waccs = xr.where(discount_factor < 0, np.nan, estimated_waccs)
        wacc_da = xr.DataArray(estimated_waccs, coords={"latitude": latitudes, "longitude":longitudes})
        data['Benchmark_WACC'] = xr.where(np.isnan(initial_lcoe)==True, np.nan, wacc_da)

        return data
    
    
    
    def convert_to_nominal(self, discount_rate, inflation_rate):
        
        # Convert discount rate to correct units
        if discount_rate > 1:
            discount_rate = discount_rate / 100
        
        # Fisher Equation
        nominal_rate = (1 + discount_rate) * (1 + inflation_rate) - 1
        
        return nominal_rate
    
    
    def calculate_lcoe_v4(self, data, technology, uniform_factor=None, nominal=None, country_list=None, reductions=None):
                
        def calculate_wacc(electricity_production, technology, index, wacc_lb, wacc_ub, national_wacc=None):
            
            # Extract country grids
            if technology == "Offshore Wind":
                country_grids = self.sea_grids.copy()
            else:
                country_grids = self.land_grids.copy()
            
            # Calculate national WACC if specified
            if national_wacc is not None:
                locational_waccs = xr.where(country_grids == index, national_wacc, np.nan)
                
                return locational_waccs
                
            # Get a subset of electricity_production
            national_electricity_production = xr.where(country_grids == index, electricity_production, np.nan)
            
            # Extract min, mean and max electricity production
            national_min = np.nanmin(national_electricity_production)
            national_max = np.nanmax(national_electricity_production)
            
            # Apply a mapping where max electricity production has the minimum wacc
            locational_waccs = xr.where(country_grids == index, wacc_ub - (national_electricity_production - national_min) / (national_max - national_min) * (wacc_ub - wacc_lb), np.nan)
            
            return locational_waccs
        
        # Extract country grids
        if technology == "Offshore Wind":
            country_index_mapping = self.sea_grids.copy()
        else:
            country_index_mapping = self.land_grids.copy()
        
        # Check if country list is none - if not then list all country numbers
        if country_list is None:
            countries_examined = np.arange(1, 251, 1)
        else:
            countries_examined = country_list
            
        # Convert uniform value into a decimal
        uniform_factor = uniform_factor / 100
            
        # Read in country waccs
        country_waccs = self.country_wacc_mapping
        country_waccs_ub = self.country_wacc_ub
        country_waccs_lb = self.country_wacc_lb
        
        # Apply risk reductions, where required
        if reductions is not None:
            rf_rate = self.CoCModel_class.rf_rate
            country_waccs[['onshore_wacc', 'offshore_wacc', 'solar_pv_wacc']] = (country_waccs[['onshore_wacc', 'offshore_wacc', 'solar_pv_wacc']] - rf_rate) * ((100 - reductions) / 100) + rf_rate 

        # Read in parameters from the data
        electricity_production = data['electricity_production']
        
         # Extract Country CAPEX values
        if technology == "Onshore Wind":
            capex_costs = self.capex_mapping[['index', 'Wind_CAPEX_2023']]
            capex_costs = capex_costs.rename(columns={"index":"country", "Wind_CAPEX_2023":"CAPEX"})
        elif technology == "Solar":
            capex_costs = self.capex_mapping[['index', 'Solar_CAPEX_2023']]
            capex_costs = capex_costs.rename(columns={"index":"country", "Solar_CAPEX_2023":"CAPEX"})
        elif technology == "Offshore Wind":
            capex_costs = self.capex_mapping[['index', 'Offshore_CAPEX_2023']]
            capex_costs = capex_costs.rename(columns={"index":"country", "Offshore_CAPEX_2023":"CAPEX"})

        
        # Loop over every country
        for index in countries_examined:
            
            if index == 1:
                data['Calculated_LCOE'] = xr.full_like(data['CF'], np.nan)
                data['Calculated_CAPEX'] = xr.full_like(data['CF'], np.nan)
                data['Calculated_OPEX'] = xr.full_like(data['CF'], np.nan)
                data['Estimated_WACC'] = xr.full_like(data['CF'], np.nan)
                data['Country'] = xr.full_like(data['CF'], np.nan)
                data['Subnational_LCOE'] = xr.full_like(data['CF'], np.nan)
                data['Subnational_WACC'] = xr.full_like(data['CF'], np.nan)
                if uniform_factor is not None:
                    data['Uniform_LCOE'] = xr.full_like(data['CF'], np.nan)

            
            # Calculate total capital costs for the given renewables capacity
            capex = float(capex_costs[capex_costs['country']==index]['CAPEX'].values * self.renewables_capacity)
            
            # Get WACC values for the country and calculate the OPEX using the CAPEX
            row = country_waccs.loc[country_waccs['index'] == index]
            if technology == "Onshore Wind":
                estimated_wacc = row['onshore_wacc'].values[0]
                opex = self.wind_opex * capex # Calculate OPEX as 2.6% of CAPEX annually
            elif technology == "Solar":
                estimated_wacc = row['solar_pv_wacc'].values[0]
                opex = self.solar_opex * capex # Calculate OPEX as 2.3% of CAPEX annually
            elif technology == "Offshore Wind":
                estimated_wacc = row['offshore_wacc'].values[0]
                opex = self.offshore_opex * capex # Calculate OPEX as 3% of CAPEX annually
                
            # Get min and max waccs 
            row_lb = country_waccs_lb.loc[country_waccs_lb['index'] == index]
            row_ub = country_waccs_ub.loc[country_waccs_ub['index'] == index]
            if technology == "Onshore Wind":
                wacc_lb = row_lb['onshore_wacc'].values[0]
                wacc_ub = row_ub['onshore_wacc'].values[0]
            elif technology == "Solar":
                wacc_lb = row_lb['solar_pv_wacc'].values[0]
                wacc_ub = row_ub['solar_pv_wacc'].values[0]
            elif technology == "Offshore Wind":
                wacc_lb = row_lb['offshore_wacc'].values[0]
                wacc_ub = row_ub['offshore_wacc'].values[0]
                
            # Calculate nominal discount rate, if required. Ensure it is in a decimal format
            if nominal is not None:
                discount_rate = self.convert_to_nominal(estimated_wacc, nominal)
                lb_rate = self.convert_to_nominal(wacc_lb, nominal)
                ub_rate = self.convert_to_nominal(wacc_ub, nominal)
            else: 
                discount_rate = estimated_wacc / 100 
                lb_rate = wacc_lb / 100
                ub_rate = wacc_ub / 100
                
            # Calculate discount factor for the given location, using the discount rate
            national_discount_rate = calculate_wacc(electricity_production, technology, index, lb_rate, ub_rate, national_wacc=discount_rate)
            national_discount_factor = self.calculate_discount_factor_v3(national_discount_rate)
            
            
            # Calculate subnational discount factors
            subnational_discount_rates = calculate_wacc(electricity_production, technology, index, lb_rate, ub_rate)
            subnational_discount_factors = self.calculate_discount_factor_v3(subnational_discount_rates)
            
            # If the discount rate is NaN, don't calculate the LCOE
            if np.isnan(float(discount_rate)) == True:
                data['Calculated_LCOE'] = xr.where(country_index_mapping == index, np.nan, data['Calculated_LCOE'])
                data['Subnational_LCOE'] = xr.where(country_index_mapping == index, np.nan, data['Subnational_LCOE'])
                if uniform_factor is not None:
                    data['Uniform_LCOE'] = xr.where(country_index_mapping == index, np.nan, data['Uniform_LCOE'])
                

                continue        
            
            # Store the OPEX, CAPEX and WACC values
            data['Calculated_CAPEX'] = xr.where(country_index_mapping == index, capex, data['Calculated_CAPEX'])
            data['Calculated_OPEX'] = xr.where(country_index_mapping == index, opex, data['Calculated_OPEX'])
            data['Estimated_WACC'] = xr.where(country_index_mapping == index, national_discount_rate*100, data['Estimated_WACC']) # Store in % terms
            data['Subnational_WACC'] = xr.where(country_index_mapping == index, subnational_discount_rates*100, data['Subnational_WACC'])
            data['Country'] = xr.where(country_index_mapping == index, index, data['Country'])



            # Calculate LCOE using the OPEX, CAPEX, DF and Electricity Production
            data['Calculated_LCOE'] = xr.where(country_index_mapping == index, (capex + national_discount_factor * opex) / (national_discount_factor * electricity_production), data['Calculated_LCOE'])
            
            # Store country
            data['Subnational_LCOE'] = xr.where(country_index_mapping == index, (capex + subnational_discount_factors * opex) / (subnational_discount_factors * electricity_production), data['Subnational_LCOE'])
            
        # Convert LCOE to USD/MWh
        data['Calculated_LCOE'] = xr.where(np.isnan(data['Calculated_LCOE']), np.nan, data['Calculated_LCOE'] * 1000)
        data['Subnational_LCOE'] = xr.where(np.isnan(data['Subnational_LCOE']), np.nan, data['Subnational_LCOE'] * 1000)
            
        # Calculate uniform LCOE results
        if uniform_factor is not None:
            
            # Calculate uniform discount factor
            if nominal is not None:
                uniform_discount_rate = self.convert_to_nominal(uniform_factor, nominal)
            else:
                uniform_discount_rate = uniform_factor
            uniform_discount_factor = float(self.calculate_discount_factor_v1(uniform_discount_rate))
            
            # Loop over every country
            for index in countries_examined:
                
                # Calculate total capital costs for a 1 MW plant
                capex = float(capex_costs[capex_costs['country']==index]['CAPEX'].values * self.renewables_capacity)
                
                if technology == "Onshore Wind":
                    opex = self.wind_opex * capex # Calculate OPEX as 2.6% of CAPEX annually
                elif technology == "Solar":
                    opex = self.solar_opex * capex # Calculate OPEX as 2.3% of CAPEX annually
                elif technology == "Offshore Wind":
                    opex = self.offshore_opex * capex # Calculate OPEX as 3% of CAPEX annually

                 # Calculate LCOE
                data['Uniform_LCOE'] = xr.where(country_index_mapping == index, (capex + uniform_discount_factor * opex) / (uniform_discount_factor * electricity_production), data['Uniform_LCOE'])
                
            # Convert LCOE to USD/MWh
            data['Uniform_LCOE'] = xr.where(np.isnan(data['Uniform_LCOE']), np.nan, data['Uniform_LCOE'] * 1000)
            
            # Remove locations with no WACC computed
            data['Uniform_LCOE'] = xr.where(np.isnan(data['Calculated_LCOE']), np.nan, data['Uniform_LCOE']) 
            
        # Remove electricity production in locations with no WACC computed
        data['electricity_production'] = xr.where(np.isnan(data['Calculated_LCOE']), np.nan, data['electricity_production'])

        return data
    
    
    def run_TIAM_regions(self, region_list):
        
        # Extract the relevant data
        TIAM_regions = self.TIAM_regions 
        
        # Loop over the regions specified
        for region in region_list:
            
            # Extract country codes corresponding to the region
            country_codes = TIAM_regions[TIAM_regions['Region'] == region]
            country_codes_list = country_codes['index'].values
            
            # Calculate the average cost of capital in the region
            solar_region_wacc = self.country_wacc_mapping[self.country_wacc_mapping['index'].isin(country_codes_list)].loc[:, 'solar_pv_wacc'].mean()
            wind_region_wacc = self.country_wacc_mapping[self.country_wacc_mapping['index'].isin(country_codes_list)].loc[:, 'onshore_wacc'].mean()
            solar_region_wacc = 7
            wind_region_wacc = 7
            
            # Run the uniform calculation with the average cost of capital
            solar_results = self.calculate_lcoe_v3(self.solar_input, "Solar", uniform_factor=solar_region_wacc, country_list=np.asarray(country_codes_list))
            wind_results = self.calculate_lcoe_v3(self.wind_input, "Wind", uniform_factor=wind_region_wacc, country_list=np.asarray(country_codes_list))
            
            # Ensure that for other locations, the values are NaN
            solar_filtered_results = xr.where(self.land_grids.isin(country_codes_list), solar_results, np.nan)
            wind_filtered_results = xr.where(self.land_grids.isin(country_codes_list), wind_results, np.nan) 
            
            # Call postprocessing function to create the corresponding supply curve
            self.postprocessor.plot_TIAM_region(region, solar_filtered_results, wind_filtered_results, solar_region_wacc, wind_region_wacc)
            
        


    def run_uniform_calculation(self, lcoe_data, wacc, technology):
        
        # Extract LCOE data
        years = lcoe_data.year.values
        zeroth_year = years[0]
        first_year = years[1]
        lcoe = lcoe_data['Calculated_LCOE']
        latitudes = lcoe_data.latitude.values
        longitudes = lcoe_data.longitude.values


        # Calculate old and new discount factors
        discount_factor = self.calculate_discount_factor(wacc)

        # Extract annual costs and electricity production
        annual_electricity_production = lcoe_data['electricity_production'].sel(year=first_year).values
        if technology == "Wind":
            annual_costs = self.wind_op_cost
            capital_costs = self.wind_cost
        elif technology == "Solar":
            annual_costs = self.solar_op_cost
            capital_costs = self.solar_cost

        # Calculate new LCOE based on discount factor
        new_lcoe = xr.where(np.isnan(lcoe)==True, np.nan, (capital_costs + discount_factor * annual_costs ) / (discount_factor * annual_electricity_production))

        # Rename 
        lcoe_data['Uniform_LCOE'] = xr.DataArray(new_lcoe, coords={"latitude":latitudes, "longitude":longitudes})

        return lcoe_data
    
    
    def TIAM_cost_supply_curves(self):
        
        # Extract the relevant data
        TIAM_regions = self.TIAM_regions 

        # Specify input
        solar_results = self.solar_lcoe
        onshore_results = self.wind_lcoe
        offshore_results = self.offshore_lcoe

        # Specify uniform factors
        solar_uf = self.solar_pv_uf
        onshore_uf = self.onshore_uf
        offshore_uf = self.offshore_uf

        # Specify postprocessor
        postprocessor = self.postprocessor

        # Call postprocessing function to create the corresponding supply curve
        postprocessor.plot_TIAM_lcoe(solar_results, onshore_results, offshore_results, solar_uf, onshore_uf, offshore_uf)

    def plot_data_shading(self, values, latitudes, longitudes, anchor=None, filename=None, increment=None, title=None, tick_values=None, cmap=None, extend_set=None, graphmarking=None, special_value=None, hatch_label=None, hatch_label_2=None, special_value_2=None, center_norm=None):      
    
        # create the heatmap using pcolormesh
        if anchor is None:
            anchor = 0.355
        fig = plt.figure(figsize=(30, 15), facecolor="white")
        ax = fig.add_subplot(1, 1, 1, projection=ccrs.PlateCarree())
        if center_norm is None:
            heatmap = ax.pcolormesh(longitudes, latitudes, values, norm=colors.Normalize(vmin=tick_values[0], vmax=tick_values[-1]), transform=ccrs.PlateCarree(), cmap=cmap)
        else:
            heatmap = ax.pcolormesh(longitudes, latitudes, values, norm=colors.SymLogNorm(vmin = tick_values[0], vmax=tick_values[-1], linscale
    =1, linthresh=1), transform=ccrs.PlateCarree(), cmap=cmap)

        # Check if there is a need for extension
        values_min = np.nanmin(values)
        values_max = np.nanmax(values)
        if values_min < tick_values[0]:
            extend = "min"
        elif values_max > tick_values[-1]:
            extend = "max"
        elif (values_max > tick_values[-1]) & (values_min < tick_values[0]):
            extend = "both"
        if extend_set is not None:
            extend = extend_set

        axins = inset_axes(
        ax,
        width="1.5%",  
        height="80%",  
        loc="lower left",
        bbox_to_anchor=(1.05, 0., 1, 1),
        bbox_transform=ax.transAxes,
        borderpad=0,
    )
        cb = fig.colorbar(heatmap, cax=axins, shrink=0.5, ticks=tick_values, format="%0.0f", extend=extend, anchor=(0, anchor))


        cb.ax.tick_params(labelsize=20)
        if title is not None:
            cb.ax.set_title(title, fontsize=25)

        # Add the special shading
        if special_value is not None:
            special_overlay = np.where(values == special_value, 1, np.nan)
            hatching = ax.contourf(longitudes, latitudes, special_overlay, hatches=['/'], colors="silver", linewidth=0.15, transform=ccrs.PlateCarree())

        if special_value_2 is not None:
            special_overlay = np.where(values == special_value_2, 1, np.nan)
            hatching = ax.contourf(longitudes, latitudes, special_overlay, hatches=['/'], colors="gold", linewidth=0.15, transform=ccrs.PlateCarree())

        # set the extent and aspect ratio of the plot
        ax.set_extent([longitudes.min(), longitudes.max(), latitudes.min(), latitudes.max()], crs=ccrs.PlateCarree())
        aspect_ratio = (latitudes.max() - latitudes.min()) / (longitudes.max() - longitudes.min())
        ax.set_aspect(1)

        # add axis labels and a title
        ax.set_xlabel('Longitude', fontsize=30)
        ax.set_ylabel('Latitude', fontsize=30)
        borders = cfeature.NaturalEarthFeature(category='cultural', name='admin_0_boundary_lines_land', scale='10m', facecolor='none')
        ax.add_feature(borders, edgecolor='gray', linestyle=':')
        ax.coastlines()
        cb.ax.xaxis.set_label_position('top')
        cb.ax.xaxis.set_ticks_position('top')
        ax.coastlines()
        if graphmarking is not None:
            ax.text(0.02, 0.94, graphmarking, transform=ax.transAxes, fontsize=20, fontweight='bold')

        hatch_patches=[]
        if special_value is not None and hatch_label is not None:
            hatch_patch_1 = Patch(facecolor='silver', edgecolor='black', hatch="/", label=hatch_label)
            hatch_patches.append(hatch_patch_1)

        if hatch_label_2 is not None:
            hatch_patch_2 = Patch(facecolor='gold', edgecolor='black', hatch="/", label=hatch_label_2)
            hatch_patches.append(hatch_patch_2)

        if hatch_patches:
            ax.legend(handles=hatch_patches, loc='lower left', fontsize=20)

        if filename is not None:
            plt.savefig(filename + ".png", bbox_inches="tight")

        return 



# Set out the Folder Paths
start_time = time.time()
data_path = "/Users/lukehatton/Documents/Imperial PhD/Analysis/LCOE & WACC Model/DATA/"
output_folder = "/Users/lukehatton/Documents/Imperial PhD/Analysis/LCOE & WACC Model/MANUSCRIPT_PLOTS/"

# Call the WACC Estimator function
wacc_model = WaccEstimator(data_path = data_path, country_grids = "country_grids.nc", electricity_prices="CountryElecPrices.csv", solar_results = "SOLAR_CF_MEAN.2022.nc", wind_results ="WIND_CF_MEAN.2022.nc", capex_mapping= "IRENA_Country_Costs_NEW.csv", generation_data = "Ember Yearly Data 2023.csv", crp_data = "CRPs.csv", irena_waccs = "IRENA_WACCs.csv", aures_waccs = "Aures_Data.csv", country_codes = "CountryCoding.csv", aures_diacore="Aures&DiacoreData.csv", OECD_IR = "OECD_IR.csv", IMF_IR = "IMF_IR.csv", GDP="GDPPerCapita.csv", collated_IR="Collated_IR.csv", tax_data="TaxData.csv", irena_2022 = "IRENA_CoD_CoE.csv", rise_data="RISE_Data.csv", country_mapping = "country_mapping.csv", economic_parameters = "economic_parameters.csv", output_folder = output_folder, land_cover="GlobalLandCover.nc", land_mapping = "LandUseCSV.csv", TIAM_regions="TIAM_Regions.csv", uniform_factor=4.9, solar_cf="SOLAR_CF_MEAN.2022.nc", wind_cf="WIND_CF_MEAN.2022.nc")

# Extract solar and wind results
solar_results = wacc_model.solar_lcoe
wind_results = wacc_model.wind_lcoe
offshore_results = wacc_model.offshore_lcoe


# Print duration
end_time = time.time()
total_time = end_time - start_time
print(f"LCOE Model took {total_time} seconds to run")

# Plot LCOE plots
plotting = input("Start Plotting Data? Yes/No")
if plotting == "Yes":
    wacc_model.postprocessor.plot_LCOE_comparison()
    
    
# Produce Supply Curve
plot_wacc_supply = input("Start Plotting Tech Potential - WACC? Yes/No")
plot_gdp_supply = input("GDP per capital? Yes/No")
if plot_wacc_supply == "Yes":
    if plot_gdp_supply == "Yes":
        gdp_shading=plot_gdp_supply
    else:
        gdp_shading=None
    wacc_model.postprocessor.plot_supply_curve_global(wind_uniform = wacc_model.onshore_uf, solar_uniform = wacc_model.solar_pv_uf, offshore_uniform = wacc_model.offshore_uf, subnational="true", gdp_shading=gdp_shading)


        
# Create WACC visualisation
plot_wacc_values = input("Plot WACC visualisations? Yes/No")
if plot_wacc_values == "Yes":
    wacc_model.postprocessor.plot_wacc_values(wacc_model.geodata)               
                                
    

