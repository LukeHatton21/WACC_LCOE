import numpy as np
import warnings
import xarray as xr
import time
import csv
import os
import io
import cartopy.crs as ccrs
import matplotlib.colors as colors
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from scipy.interpolate import interp1d
import cartopy.feature as cfeature
from matplotlib.patches import Patch
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
import math
import sys
import pandas as pd
import os 
import regionmask
import warnings
from joblib import Parallel, delayed
from scipy.optimize import minimize, minimize_scalar
from geodata_v2 import Global_Data
from CostofCapitalAnalyser import CoCModel
warnings.filterwarnings("ignore")

class WaccEstimator:
    def __init__(self, dataset, data_path, country_grids, electricity_prices, solar_fraction, solar_results, wind_results, capex_mapping, running_folder, generation_data, crp_data, irena_waccs, aures_waccs, country_codes, aures_diacore, OECD_IR, IMF_IR, GDP, GDP_Change, collated_IR, tax_data, irena_2022, rise_data, country_mapping, economic_parameters):     
        """ Initialises the WaccEstimator class, which can be used to calculate the WACC required to reach a specified price on a geospatial basis
       
        Inputs:
        Wind_dataset - hourly wind capacity factors, generated by RENEWABLES NINJA
        Data_path - path direction to Data inputs
        Params_file - contains the assumptions and constants used by the model
        Output_folder - folder to output results files to 
        Solar_results - Processed solar results
        Wind_results - Processed wind results"""


        # Read in input files
        self.lcoe_data = xr.open_dataset(dataset)
        self.solar_fraction = solar_fraction
        
        # Read in assumptions datafile(s)
        self.lifetime = 25
        self.renewables_capacity = 1000
        self.wind_opex = 0.026
        self.solar_opex = 0.023
            
        # Read in other inputs
        self.country_mapping = xr.open_dataset(data_path + "country_grids.nc")
        self.land_mapping = self.country_mapping['land']
        self.electricity_prices = pd.read_csv(data_path + electricity_prices)
        self.capex_mapping = pd.read_csv(data_path + capex_mapping)
        
        # Read in costs

        self.economic_parameters = pd.read_csv(data_path + economic_parameters)
        self.wind_cost = self.economic_parameters.loc[self.economic_parameters['Parameter'] == "wind_capex", "Value"].values[0] * 1000
        self.solar_cost = self.economic_parameters.loc[self.economic_parameters['Parameter'] == "solar_capex", "Value"].values[0] * 1000
        self.solar_op_cost = self.economic_parameters.loc[self.economic_parameters['Parameter'] == "solar_op_cost", "Value"].values[0] * self.solar_cost
        self.wind_op_cost = self.economic_parameters.loc[self.economic_parameters['Parameter'] == "onshore_op_cost", "Value"].values[0] * self.wind_cost
        
        
        # Get cost of capital class and estimate waccs
        start_time = time.time()
        self.CoCModel_class = CoCModel(running_folder, generation_data, crp_data, irena_waccs, aures_waccs, country_codes, aures_diacore, OECD_IR, IMF_IR, GDP, GDP_Change, collated_IR, electricity_prices, tax_data, irena_2022, rise_data, country_mapping)
        self.calculated_data, self.country_wacc_mapping= self.CoCModel_class.estimate_future_waccs_v4("Onshore_Wind_Common_Risk_2021", "Solar_Common_Risk_2021", ['Wind_Penetration_2021', "CRP_2021", "RISE_OVERALL_2021"], ['Solar_Penetration_2021', "CRP_2021","RISE_OVERALL_2021"], "2023")
        end_time = time.time()
        total_time = end_time - start_time
        print(f"Cost of Capital Analyser took {total_time} seconds to run")
        
        # Get geodata
        self.geodata_class = Global_Data((data_path + "ETOPO_bathymetry.nc"),(data_path+"distance2shore.nc"), (data_path+"country_grids.nc"), self.lcoe_data)
        self.geodata = self.geodata_class.get_countries_in_required_resolution()
        self.offshore_mask = self.geodata_class.get_offshore_mask() 
        self.lcoe_data['levelised_cost'] = xr.where(self.offshore_mask['offshore'] == 1, np.nan, self.lcoe_data['levelised_cost'])
        
        # Read in results
        self.solar_results = xr.open_dataset(solar_results)
        self.wind_results = xr.open_dataset(wind_results)
        self.solar_results, self.wind_results = self.process_inputs()
    
        # Apply calculation with new WACCs and regional costs
        self.solar_results = self.calculate_lcoe_v3(self.solar_results, "Solar", uniform_factor=7)
        self.wind_results = self.calculate_lcoe_v3(self.wind_results, "Wind", uniform_factor=7)
        
    def process_inputs(self):
        
        # Set up latitudes and longitudes for reindexing
        latitudes= np.arange(-55, 85, 0.5)
        longitudes = np.arange(-179.5, 180, 0.5)
        
        # Reindex results and country mapping
        solar_results = self.solar_results.reindex({"latitude":latitudes, "longitude":longitudes}, method="nearest")
        wind_results = self.wind_results.reindex({"latitude":latitudes, "longitude":longitudes}, method="nearest")
        land_mapping = self.country_mapping['land'].reindex({"latitude":latitudes, "longitude": longitudes}, method="nearest")
        self.land_mapping = land_mapping
        
        # Get rid of results in the ocean
        solar_results = xr.where(np.isnan(land_mapping)==True, np.nan, solar_results)
        
        # Calculate annual electricity production
        solar_results['electricity_production'] = solar_results['CF'] * 8760 * self.renewables_capacity
        wind_results['electricity_production'] = wind_results['CF'] * 8760 * self.renewables_capacity
        
        # Store Size
        solar_results['capacity'] = xr.ones_like(solar_results['CF']) * self.renewables_capacity
        wind_results['capacity'] = xr.ones_like(wind_results['CF']) * self.renewables_capacity
        
        return solar_results, wind_results
    
    def calculate_discount_factor(self, discount_rate, dcf=None):
        
        discount_factor = 0
        if dcf is None:
            initial_year = 1
        else:
            initial_year = 2
        for i in np.arange(initial_year, self.lifetime + initial_year, 1):
            discount_factor = discount_factor + 1 / ((1 + discount_rate) ** i)
            
        return discount_factor
    
    
    def get_relative_costs(self, data, countries):
    
        geodata = self.geodata['land']
        geodata = geodata.reindex({"latitude":data.latitude, "longitude":data.longitude})
        countries_in_mapping = xr.where(np.isin(geodata, countries), data['Initial_LCOE'], np.nan)
        countries_outside = xr.where(np.isin(geodata, countries), np.nan, data['Initial_LCOE'])

        mean_in = np.nanmean(countries_in_mapping)
        mean_out = np.nanmean(countries_outside)
        increase = mean_out / mean_in
        print(f"Countries not in the mapping are {(increase-1)*100:0.2f}% more expensive") 
    
    
    def get_system_costs_v2(self, benchmark_lcoe, technology):

        # Create a storage array
        system_costs = xr.full_like(self.land_mapping, np.nan)

        # Extract dataframe that contains the wind and solar penetration
        renewable_penetration = self.calculated_data[['index', 'Wind_Penetration_2023', 'Solar_Penetration_2023']]
        renewable_penetration['Penetration'] = renewable_penetration['Wind_Penetration_2023'] + renewable_penetration['Solar_Penetration_2023']
        ren_penetration = renewable_penetration[['index', 'Penetration']]  
        solar_penetration = renewable_penetration[['index', 'Solar_Penetration_2023']]  
        wind_penetration = renewable_penetration[['index', 'Wind_Penetration_2023']]  

        # Loop over country indexes
        for index in np.arange(1, 251, 1): 
            # Calculate Penetration
            penetration = ren_penetration.loc[ren_penetration['index'] == index]
            wind = wind_penetration.loc[wind_penetration['index'] == index]
            solar = solar_penetration.loc[solar_penetration['index'] == index]
            
            if penetration.empty:
                system_costs = xr.where(self.land_mapping == index, 0, system_costs)
                continue

            penetration_value = penetration['Penetration'].values[0] / 100
            solar_value = solar['Solar_Penetration_2023'].values[0] / 100
            wind_value = wind['Wind_Penetration_2023'].values[0] / 100

            # Calculate Balancing Costs
            balancing = 7.28 * penetration_value + 2.215
            

            # Calculate Profile Costs for wind
            if technology == "Wind":
                profile = 60.4 * wind_value + 3.35
            else:
                profile = 0 

            # Calculate system costs
            system_costs = xr.where(self.land_mapping == index, profile + balancing, system_costs)

        # Calculate benchmark value
        benchmark_values = xr.where(np.isnan(system_costs), np.nan, (benchmark_lcoe - system_costs ) ) / 1000

        return benchmark_values

    def calculate_required_waccs(self, data, lcoe=None, benchmark_lcoe=None, technology=None):

        # Drop existing data
        data = data.drop_vars('Required_WACC', errors="ignore")
        
        # Convert LCOE to USD/kWh
        lcoe = lcoe / 1000

        # Extract key figures from the data
        latitudes = data.latitude.values
        longitudes = data.longitude.values
        annual_electricity_production = data['electricity_production'] # kWh for 1 MW
        initial_lcoe = data['Calculated_LCOE'] # USD/KWh for 1 MW

        # Calculate annual costs
        annual_costs = data['Calculated_OPEX'] # USD/kW/year
        capital_costs = data['Calculated_CAPEX'] # USD for 1 MW


        # Get LCOE 
        if lcoe is None:
            lcoe = self.get_system_costs_v2(benchmark_lcoe, technology)
            lcoe = xr.where(np.isnan(initial_lcoe), np.nan, lcoe)
            data['Benchmark_LCOE'] = lcoe
        else:
            data['Benchmark_LCOE'] = xr.full_like(data['Calculated_CAPEX'], lcoe)

        # Calculate discount factor at each location
        # Ensure that the denominator is not zero or negative
        valid_mask = (annual_electricity_production * lcoe - annual_costs) > 0

        # Apply the calculation only where valid
        discount_factor = xr.where(
            np.isnan(lcoe) | ~valid_mask,
            np.nan,
            capital_costs / ((annual_electricity_production * lcoe) - annual_costs)
        )

        data['Discount_Factor'] = discount_factor

        # Create array of discount factor to WACC values and round discount factor
        discount_rates = np.linspace(0, 0.24, 1001)
        discount_factors_array = self.calculate_discount_factor(discount_rates)
        xdata = discount_rates
        ydata = discount_factors_array

        # Calculate curve fit
        ylog_data = np.log(ydata)
        curve_fit = np.polyfit(xdata, ylog_data, 2)
        y = np.exp(curve_fit[2]) * np.exp(curve_fit[1]*xdata) * np.exp(curve_fit[0]*xdata**2)


        # Create interpolator
        interpolator = interp1d(ydata, xdata, kind='nearest', bounds_error=False, fill_value=(0.24, 9.99))

        # Use rounded discount factors to calculate WACC values 
        estimated_waccs = interpolator(discount_factor)*100
        estimated_waccs = xr.where(discount_factor < 0, 999, estimated_waccs)
        estimated_waccs = xr.where(discount_factor < 0, np.nan, estimated_waccs)
        wacc_da = xr.DataArray(estimated_waccs, coords={"latitude": latitudes, "longitude":longitudes})
        data['Benchmark_WACC'] = xr.where(np.isnan(initial_lcoe)==True, np.nan, wacc_da)

        return data
    
    
    def calculate_lcoe_v2(self, data, technology, uniform_factor=None, no_capex_correction=None):
        
        
        # Read in country waccs
        country_waccs = self.country_wacc_mapping

        # Read in parameters from the data
        electricity_production = data['electricity_production'].sel(year=2025)
        total_capex = data['total_capital_costs']
        total_opex = data['total_costs'].sel(year=2025)

         # Select correction factor to use for regional capex
        if technology == "Wind":
            capex_costs = self.capex_mapping[['index', 'Wind_Percentage']]
            capex_costs = capex_costs.rename(columns={"index":"country", "Wind_Percentage":"Percentage"})
            total_renew_costs = data['wind_costs'].sel(year=2022)
        else:
            capex_costs = self.capex_mapping[['index', 'Solar_Percentage']]
            capex_costs = capex_costs.rename(columns={"index":"country", "Solar_Percentage":"Percentage"})
            total_renew_costs = data['solar_costs'].sel(year=2022)

        
        # Loop over every country
        for index in np.arange(1, 251, 1):
            
            if index == 1:
                data['Calculated_LCOE'] = xr.full_like(data['Initial_LCOE_REN'], np.nan)
                data['Calculated_CAPEX'] = xr.full_like(data['Initial_LCOE_REN'], np.nan)
                data['Calculated_OPEX'] = xr.full_like(data['Initial_LCOE_REN'], np.nan)
                data['Estimated_WACC'] = xr.full_like(data['Initial_LCOE_REN'], np.nan)
                if uniform_factor is not None:
                    data['Uniform_LCOE'] = xr.full_like(data['Initial_LCOE_REN'], np.nan)

            # Get WACC value
            row = country_waccs.loc[country_waccs['index'] == index]
            if technology == "Wind":
                discount_rate = row['onshore_wacc']
            elif technology == "Solar":
                discount_rate = row['solar_pv_wacc']
            print("Discount rate is :" + discount_rate)
            discount_factor = float(self.calculate_discount_factor(discount_rate / 100))
            # If the discount rate is NaN, don't calculate the LCOE
            if np.isnan(float(discount_rate)) == True:
                data['Calculated_LCOE'] = xr.where(self.land_mapping == index, np.nan, data['Calculated_LCOE'])

                continue        

            # Calculate CAPEX cost adjustment and apply
            capex_correction = float(capex_costs[capex_costs['country']==index]['Percentage'].values)
            if no_capex_correction is not None:
                capex_correction = 1
            if technology == "Wind":
                data['wind_costs'] = xr.where(self.land_mapping == index, data['wind_costs'] * capex_correction, data['wind_costs'])
            else:
                data['solar_costs'] = xr.where(self.land_mapping == index, data['solar_costs'] * capex_correction, data['solar_costs'])
                
            

            # Calculate CAPEX and OPEX
            country_capex = xr.where(self.land_mapping == index, total_capex * capex_correction, np.nan)
            
            country_opex = xr.where(self.land_mapping == index, total_opex  * capex_correction, np.nan)
            
            # Store the OPEX, CAPEX and WACC values
            data['Calculated_CAPEX'] = xr.where(self.land_mapping == index, country_capex, data['Calculated_CAPEX'])
            data['Calculated_OPEX'] = xr.where(self.land_mapping == index, country_opex, data['Calculated_OPEX'])
            data['Estimated_WACC'] = xr.where(self.land_mapping == index, float(discount_rate), data['Estimated_WACC'])



            # Calculate LCOE
            data['Calculated_LCOE'] = xr.where(self.land_mapping == index, (country_capex + discount_factor * country_opex) / (discount_factor * electricity_production), data['Calculated_LCOE'])
            
            if uniform_factor is not None:
                
                # Calculate discount factor
                uniform_discount_factor = float(self.calculate_discount_factor(uniform_factor / 100))

                 # Calculate LCOE
                data['Uniform_LCOE'] = xr.where(self.land_mapping == index, ((1/(1 + float(discount_rate)))*country_capex + uniform_discount_factor * country_opex) / (uniform_discount_factor * electricity_production), data['Uniform_LCOE'])
        
        # Apply limits
        data['Calculated_LCOE'] = xr.where(data['Calculated_LCOE'] < 0.0001, np.nan, data['Calculated_LCOE'])
        if uniform_factor is not None:
            data['Uniform_LCOE'] = xr.where(data['Uniform_LCOE'] < 0.0001, np.nan, data['Uniform_LCOE'])
        #data['Calculated_LCOE'] = xr.where(data['Calculated_LCOE'] > 200, np.nan, data['Calculated_LCOE'])
        
        # Drop variables
        data = data.drop_vars(names=["total_capital_costs", "total_costs", "Initial_LCOE", "Initial_LCOE_REN", "Regional_LCOE", "Regional_LCOE_REN", "Regional_total_costs", "solar_costs", "wind_costs"], errors="ignore")    

        return data
    
    
    def convert_to_nominal(self, discount_rate, inflation_rate):
        
        # Convert discount rate to correct units
        if discount_rate > 1:
            discount_rate = discount_rate / 100
        
        # Fisher Equation
        nominal_rate = (1 + discount_rate) * (1 + inflation_rate) - 1
        
        # Convert
        
        return nominal_rate
        
    
    def calculate_lcoe_v3(self, data, technology, uniform_factor=None, no_capex_correction=None):
        
        
        # Read in country waccs
        country_waccs = self.country_wacc_mapping

        # Read in parameters from the data
        electricity_production = data['electricity_production']
        
         # Extract Country CAPEX values
        if technology == "Wind":
            capex_costs = self.capex_mapping[['index', 'Wind_CAPEX_2023']]
            capex_costs = capex_costs.rename(columns={"index":"country", "Wind_CAPEX_2023":"CAPEX"})
        else:
            capex_costs = self.capex_mapping[['index', 'Solar_CAPEX_2023']]
            capex_costs = capex_costs.rename(columns={"index":"country", "Solar_CAPEX_2023":"CAPEX"})
            

        
        # Loop over every country
        for index in np.arange(1, 251, 1):
            
            if index == 1:
                data['Calculated_LCOE'] = xr.full_like(data['CF'], np.nan)
                data['Calculated_CAPEX'] = xr.full_like(data['CF'], np.nan)
                data['Calculated_OPEX'] = xr.full_like(data['CF'], np.nan)
                data['Estimated_WACC'] = xr.full_like(data['CF'], np.nan)
                data['Discount_Factor'] = xr.full_like(data['CF'], np.nan)
                if uniform_factor is not None:
                    data['Uniform_LCOE'] = xr.full_like(data['CF'], np.nan)
                    data['Uniform_DF'] = xr.full_like(data['CF'], np.nan)

            
            # Calculate CAPEX costs adjustment and apply
            capex = float(capex_costs[capex_costs['country']==index]['CAPEX'].values* self.renewables_capacity)
            
            # Get WACC value
            row = country_waccs.loc[country_waccs['index'] == index]
            if technology == "Wind":
                discount_rate = row['onshore_wacc'].values[0]
                nominal_discount_rate = self.convert_to_nominal(discount_rate, 0.03)
                opex = self.wind_opex * capex 
            elif technology == "Solar":
                discount_rate = row['solar_pv_wacc'].values[0]
                nominal_discount_rate = self.convert_to_nominal(discount_rate, 0.03)
                opex = self.solar_opex * capex 
                
            # Calculate discount factor
            discount_factor = float(self.calculate_discount_factor(nominal_discount_rate))
            
            # If the discount rate is NaN, don't calculate the LCOE
            if np.isnan(float(discount_rate)) == True:
                data['Calculated_LCOE'] = xr.where(self.land_mapping == index, np.nan, data['Calculated_LCOE'])

                continue        
            
            # Store the OPEX, CAPEX and WACC values
            data['Calculated_CAPEX'] = xr.where(self.land_mapping == index, capex, data['Calculated_CAPEX'])
            data['Calculated_OPEX'] = xr.where(self.land_mapping == index, opex, data['Calculated_OPEX'])
            data['Estimated_WACC'] = xr.where(self.land_mapping == index, float(discount_rate), data['Estimated_WACC'])
            data['Discount_Factor'] = xr.where(self.land_mapping == index, discount_factor, data['Discount_Factor'])



            # Calculate LCOE
            data['Calculated_LCOE'] = xr.where(self.land_mapping == index, (capex + discount_factor * opex) / (discount_factor * electricity_production), data['Calculated_LCOE'])
            
            if uniform_factor is not None:
                
                # Calculate discount factor
                nominal_uniform_rate = self.convert_to_nominal(uniform_factor, 0.03)
                uniform_discount_factor = float(self.calculate_discount_factor(nominal_uniform_rate))

                 # Calculate LCOE
                data['Uniform_LCOE'] = xr.where(self.land_mapping == index, (capex + uniform_discount_factor * opex) / (uniform_discount_factor * electricity_production), data['Uniform_LCOE'])
                data['Uniform_DF'] = xr.where(self.land_mapping == index, uniform_discount_factor, data['Uniform_DF'])
        
        # Apply limits
        data['Calculated_LCOE'] = xr.where(data['Calculated_LCOE'] < 0.0001, np.nan, data['Calculated_LCOE'])
        if uniform_factor is not None:
            data['Uniform_LCOE'] = xr.where(data['Uniform_LCOE'] < 0.0001, np.nan, data['Uniform_LCOE'])
            

        return data


    def run_uniform_calculation(self, lcoe_data, wacc, technology):
        
        # Extract LCOE data
        years = lcoe_data.year.values
        zeroth_year = years[0]
        first_year = years[1]
        lcoe = lcoe_data['Calculated_LCOE']
        latitudes = lcoe_data.latitude.values
        longitudes = lcoe_data.longitude.values


        # Calculate old and new discount factors
        discount_factor = self.calculate_discount_factor(wacc)

        # Extract annual costs and electricity production
        annual_electricity_production = lcoe_data['electricity_production'].sel(year=first_year).values
        if technology == "Wind":
            annual_costs = self.wind_op_cost
            capital_costs = self.wind_cost
        elif technology == "Solar":
            annual_costs = self.solar_op_cost
            capital_costs = self.solar_cost

        # Calculate new LCOE based on discount factor
        new_lcoe = xr.where(np.isnan(lcoe)==True, np.nan, (capital_costs + discount_factor * annual_costs ) / (discount_factor * annual_electricity_production))

        # Rename 
        lcoe_data['Uniform_LCOE'] = xr.DataArray(new_lcoe, coords={"latitude":latitudes, "longitude":longitudes})

        return lcoe_data
    
    def get_relative_costs(self, data, countries_1, countries_2):

        geodata = self.land_mapping
        geodata = geodata.reindex({"latitude":data.latitude, "longitude":data.longitude})
        countries_1 = xr.where(np.isin(geodata, countries_1), data['Calculated_LCOE'], np.nan)
        countries_2 = xr.where(np.isin(geodata, countries_2), data['Calculated_LCOE'], np.nan)

        mean_1 = np.nanmean(countries_1)
        mean_2 = np.nanmean(countries_2)
        increase = mean_1 / mean_2
        print(f"Countries in group 1 are {(increase-1)*100:0.2f}% more expensive than in group 2") 

    def plot_data_shading(self, values, latitudes, longitudes, anchor=None, filename=None, increment=None, title=None, tick_values=None, cmap=None, extend_set=None, graphmarking=None, special_value=None, hatch_label=None, hatch_label_2=None, special_value_2=None, center_norm=None):      
    
        # create the heatmap using pcolormesh
        if anchor is None:
            anchor = 0.355
        fig = plt.figure(figsize=(30, 15), facecolor="white")
        ax = fig.add_subplot(1, 1, 1, projection=ccrs.PlateCarree())
        if center_norm is None:
            heatmap = ax.pcolormesh(longitudes, latitudes, values, norm=colors.Normalize(vmin=tick_values[0], vmax=tick_values[-1]), transform=ccrs.PlateCarree(), cmap=cmap)
        else:
            heatmap = ax.pcolormesh(longitudes, latitudes, values, norm=colors.SymLogNorm(vmin = tick_values[0], vmax=tick_values[-1], linscale
    =1, linthresh=1), transform=ccrs.PlateCarree(), cmap=cmap)

        # Check if there is a need for extension
        values_min = np.nanmin(values)
        values_max = np.nanmax(values)
        if values_min < tick_values[0]:
            extend = "min"
        elif values_max > tick_values[-1]:
            extend = "max"
        elif (values_max > tick_values[-1]) & (values_min < tick_values[0]):
            extend = "both"
        elif extend_set is not None:
            extend = extend_set
        else:
            extend = "neither"

        axins = inset_axes(
        ax,
        width="1.5%",  
        height="80%",  
        loc="lower left",
        bbox_to_anchor=(1.05, 0., 1, 1),
        bbox_transform=ax.transAxes,
        borderpad=0,
    )
        cb = fig.colorbar(heatmap, cax=axins, shrink=0.5, ticks=tick_values, format="%0.0f", extend=extend, anchor=(0, anchor))


        cb.ax.tick_params(labelsize=20)
        if title is not None:
            cb.ax.set_title(title, fontsize=25)

        # Add the special shading
        if special_value is not None:
            special_overlay = np.where(values == special_value, 1, np.nan)
            hatching = ax.contourf(longitudes, latitudes, special_overlay, hatches=['/'], colors="silver", linewidth=0.15, transform=ccrs.PlateCarree())

        if special_value_2 is not None:
            special_overlay = np.where(values == special_value_2, 1, np.nan)
            hatching = ax.contourf(longitudes, latitudes, special_overlay, hatches=['\\'], colors="gold", linewidth=0.15, transform=ccrs.PlateCarree())

        # set the extent and aspect ratio of the plot
        ax.set_extent([longitudes.min(), longitudes.max(), latitudes.min(), latitudes.max()], crs=ccrs.PlateCarree())
        aspect_ratio = (latitudes.max() - latitudes.min()) / (longitudes.max() - longitudes.min())
        ax.set_aspect(1)

        # add axis labels and a title
        ax.set_xlabel('Longitude', fontsize=30)
        ax.set_ylabel('Latitude', fontsize=30)
        borders = cfeature.NaturalEarthFeature(category='cultural', name='admin_0_boundary_lines_land', scale='10m', facecolor='none')
        ax.add_feature(borders, edgecolor='gray', linestyle=':')
        ax.coastlines()
        cb.ax.xaxis.set_label_position('top')
        cb.ax.xaxis.set_ticks_position('top')
        ax.coastlines()
        if graphmarking is not None:
            ax.text(0.02, 0.94, graphmarking, transform=ax.transAxes, fontsize=20, fontweight='bold')

        hatch_patches=[]
        if special_value is not None and hatch_label is not None:
            hatch_patch_1 = Patch(facecolor='silver', edgecolor='black', hatch="/", label=hatch_label)
            hatch_patches.append(hatch_patch_1)

        if hatch_label_2 is not None:
            hatch_patch_2 = Patch(facecolor='gold', edgecolor='black', hatch="/", label=hatch_label_2)
            hatch_patches.append(hatch_patch_2)

        if hatch_patches:
            ax.legend(handles=hatch_patches, loc='lower left', fontsize=20)

        if filename is not None:
            plt.savefig(filename + ".png", bbox_inches="tight")

        return 

        


# Run the Cost of Capital Model



# Call for Wind
start_time = time.time()
data_path = "/Users/lukehatton/Documents/Imperial PhD/Analysis/LCOE & WACC Model/DATA/"
output_folder = "/Users/lukehatton/Documents/Imperial PhD/Analysis/LCOE & WACC Model/OUTPUT_FOLDER/"
data_name = "WindGlobalResults.nc"
solar_fraction = 0

# Call the WACC Estimator function
wacc_model = WaccEstimator(dataset = output_folder + data_name, data_path = data_path, country_grids = "country_grids.nc", electricity_prices="CountryElecPrices.csv", solar_fraction = solar_fraction, solar_results = output_folder + "SOLAR_CF_MEAN.2022.nc", wind_results = output_folder + "WIND_CF_MEAN.2022.nc", capex_mapping= "IRENA_Country_Costs_NEW.csv", running_folder = data_path, generation_data = "Ember Yearly Data 2023.csv", crp_data = "CRPs.csv", irena_waccs = "IRENA_WACCs.csv", aures_waccs = "Aures_Data.csv", country_codes = "CountryCoding.csv", aures_diacore="Aures&DiacoreData.csv", OECD_IR = "OECD_IR.csv", IMF_IR = "IMF_IR.csv", GDP="GDPPerCapita.csv", GDP_Change="GDPPerCapitaChange.csv", collated_IR="Collated_IR.csv", tax_data="TaxData.csv", irena_2022 = "IRENA_CoD_CoE.csv", rise_data="RISE_Data.csv", country_mapping = "country_mapping.csv", economic_parameters = "economic_parameters.csv")

# Extract solar and wind results
solar_results =  wacc_model.solar_results
wind_results =  wacc_model.wind_results


#solar_results =  wacc_model.run_uniform_calculation(wacc_model.solar_results, 0.07, "Solar")
#wind_results =  wacc_model.run_uniform_calculation(wacc_model.wind_results, 0.07, "Wind")
end_time = time.time()
total_time = end_time - start_time
print(f"LCOE Model took {total_time} seconds to run")

plotting = input("Start Plotting Data? Yes/No")

# Setup output folder and remove zero latitude from wind
output_folder = "/Users/lukehatton/Documents/Imperial PhD/Analysis/LCOE & WACC Model/MANUSCRIPT_PLOTS/"

# Plot LCOE plots
if plotting == "Yes":
    wind_results = wind_results.drop_sel(latitude=0)
    wacc_model.plot_data_shading(solar_results['Calculated_LCOE']*1000, solar_results.latitude, solar_results.longitude, tick_values=[0, 25, 50, 75, 100], graphmarking="a", cmap="YlOrRd", filename = output_folder + "Solar_LCOE_Country_NEW", title="LCOE\n (US$/MWh)\n")
    wacc_model.plot_data_shading(solar_results['Uniform_LCOE']*1000, solar_results.latitude, solar_results.longitude, tick_values=[0, 25, 50, 75, 100], graphmarking="b", cmap="YlOrRd", filename = output_folder + "Solar_LCOE_Uniform_NEW", title="LCOE\n (US$/MWh)\n")
    wacc_model.plot_data_shading(wind_results['Calculated_LCOE']*1000, wind_results.latitude, wind_results.longitude, tick_values=[0, 25, 50, 75, 100, 150], graphmarking="a", cmap="YlGnBu", filename = output_folder + "Wind_LCOE_Country_NEW", title="LCOE\n (US$/MWh)\n")
    wacc_model.plot_data_shading(wind_results['Uniform_LCOE']*1000, wind_results.latitude, wind_results.longitude, tick_values=[0, 25, 50, 75, 100, 150], graphmarking="b", cmap="YlGnBu", filename = output_folder + "Wind_LCOE_Uniform_NEW", title="LCOE\n (US$/MWh)\n")
    wacc_model.plot_data_shading((solar_results['Calculated_LCOE'] - solar_results['Uniform_LCOE'])*1000, solar_results.latitude, solar_results.longitude, tick_values=[-50, -25, 0, 25, 50], graphmarking="a", cmap="coolwarm", filename = output_folder + "Solar_LCOE_Change_NEW", title="Solar PV:\nIncrease in\n LCOE from\n 7% Scenario\n(US$/MWh)\n", extend_set="max")
    wacc_model.plot_data_shading((wind_results['Calculated_LCOE'] - wind_results['Uniform_LCOE'])*1000, wind_results.latitude, wind_results.longitude, tick_values=[-50, -25, 0, 25, 50], graphmarking="b", cmap="coolwarm", filename = output_folder + "Wind_LCOE_Change_NEW", title="Onshore Wind:\nIncrease in\nLCOE from\n7% Scenario\n(US$/MWh)\n", extend_set="max")
    
## GLOBAL COSTS WITHOUT SYSTEM IMPLICATIONS

# Estimate the required WACC to reach cost parity with global costs
solar_benchmark_results = wacc_model.calculate_required_waccs(solar_results, lcoe = 60, technology="Solar")
wind_benchmark_results = wacc_model.calculate_required_waccs(wind_results, lcoe = 50, technology="Wind")

# Calculate WACC 
solar_benchmark_wacc = solar_benchmark_results['Benchmark_WACC']
wind_benchmark_wacc = wind_benchmark_results['Benchmark_WACC']

# Compare WACC to the reductions required
wacc_reductions_solar = xr.where(np.isnan(solar_benchmark_results['Calculated_LCOE'])==True, np.nan, xr.where(solar_benchmark_results['Estimated_WACC'] > solar_benchmark_wacc,solar_benchmark_results['Estimated_WACC'] - solar_benchmark_wacc, 999))
wacc_reductions_wind = xr.where(np.isnan(wind_benchmark_results['Calculated_LCOE'])==True, np.nan,xr.where(wind_benchmark_results['Estimated_WACC'] > wind_benchmark_wacc, wind_benchmark_results['Estimated_WACC'] - wind_benchmark_wacc, 999))

# Apply hatching to where the cost is unachievable
wacc_reductions_solar = xr.where(solar_benchmark_results['Benchmark_WACC'] == 999, 999, wacc_reductions_solar)
wacc_reductions_wind = xr.where(wind_benchmark_results['Benchmark_WACC'] == 999, 999, wacc_reductions_wind)

# Apply hatching to locations already below the system cost of renewables
wacc_reductions_solar = xr.where(solar_benchmark_results['Calculated_LCOE'] < solar_benchmark_results['Benchmark_LCOE'], 111, wacc_reductions_solar)
wacc_reductions_wind = xr.where(wind_benchmark_results['Calculated_LCOE'] < wind_benchmark_results['Benchmark_LCOE'], 111, wacc_reductions_wind)

# Remove latitude of zero from wind
#wacc_reductions_wind = wacc_reductions_wind.drop_sel(latitude=0)

plot_wacc_results = input("Start Plotting LCOE (No System Costs)? Yes/No")

if plot_wacc_results == "Yes":
    # Plot for the base case
    wacc_model.plot_data_shading(wacc_reductions_solar, wacc_reductions_solar.latitude, wacc_reductions_solar.longitude, tick_values = [0, 5, 10, 15, 20, 25], special_value=999, hatch_label="Above US$60/MWh\nat a WACC of 0%", title="Reductions\nin WACC\n Required (%)\n", cmap="YlOrRd", special_value_2 = 111, hatch_label_2 = "Below US$60/MWh", graphmarking="a", extend_set="neither", filename = output_folder + "Solar_Benchmark_Cost")
    wacc_model.plot_data_shading(wacc_reductions_wind, wacc_reductions_wind.latitude, wacc_reductions_wind.longitude, tick_values = [0, 5, 10, 15, 20, 25], special_value=999, hatch_label="Above US$49/MWh\nat a WACC of 0%", special_value_2 = 111, hatch_label_2 = "Below US$49/MWh", title="Reductions\nin WACC\n Required (%)\n", cmap="YlGnBu", graphmarking="b", extend_set="neither", filename = output_folder + "Wind_Benchmark_Cost") 



    
def get_utilisations(land_cover, land_mapping, annual_production, technology):

    latitudes = annual_production.latitude.values
    longitudes = annual_production.longitude.values
    global_cover = land_cover.reindex_like(annual_production, method="nearest")
    mapping = land_mapping

    utilisation = xr.zeros_like(global_cover['cover'])
    for i in np.arange(0, 21, 1):
        # Use xarray's where and isin functions to map land use categories to values
        if technology == "Solar":
            utilisation = xr.where(global_cover['cover'] == mapping['Number'].iloc[i], mapping['PV LU'].iloc[i], utilisation)
        elif technology =="Wind":
            utilisation = xr.where(global_cover['cover'] == mapping['Number'].iloc[i], mapping['Wind LU'].iloc[i], utilisation)   

    return utilisation    


def get_areas(annual_production):

    latitudes = annual_production.latitude.values
    longitudes = annual_production.longitude.values

    # Add an extra value to latitude and longitude coordinates
    latitudes_extended = np.append(latitudes, latitudes[-1] + np.diff(latitudes)[-1])
    longitudes_extended = np.append(longitudes, longitudes[-1] + np.diff(longitudes)[-1])

    # Calculate the differences between consecutive latitude and longitude points
    dlat_extended = np.diff(latitudes_extended)
    dlon_extended = np.diff(longitudes_extended)

    # Calculate the Earth's radius in kms
    radius = 6371

    # Compute the mean latitude value for each grid cell
    mean_latitudes_extended = (latitudes_extended[:-1] + latitudes_extended[1:]) / 2
    mean_latitudes_2d = mean_latitudes_extended[:, np.newaxis]

    # Convert the latitude differences and longitude differences from degrees to radians
    dlat_rad_extended = np.radians(dlat_extended)
    dlon_rad_extended = np.radians(dlon_extended)

    # Compute the area of each grid cell using the Haversine formula
    areas_extended = np.outer(dlat_rad_extended, dlon_rad_extended) * (radius ** 2) * np.cos(np.radians(mean_latitudes_2d))

    # Create a dataset with the three possible capital expenditures 
    area_dataset = xr.Dataset()
    area_dataset['latitude'] = latitudes
    area_dataset['longitude'] = longitudes
    area_dataset['area'] = (['latitude', 'longitude'], areas_extended, {'latitude': latitudes, 'longitude': longitudes})

    return area_dataset


def get_supply_curves(land_cover, land_mapping, levelised_costs, uniform_costs, annual_production, waccs, technology, country_grids, plot_global=None):


    # Calculate area of each grid point in kms 
    latitudes = annual_production.latitude.values
    longitudes = annual_production.longitude.values
    grid_areas = get_areas(annual_production)
    utilisation_factors = get_utilisations(land_cover, land_mapping, annual_production, technology)

    # Set out constants
    if technology == "Wind":
        power_density = 6520 # kW/km2
    elif technology == "Solar":
        power_density = 32950  # kW/km2
    elif technology == "Hybrid":
        power_density = 6520 + solar_fractions * (32950 - 6520)
    installed_capacity = 1000

    # Scale annual hydrogen production by turbine density
    max_installed_capacity = power_density * grid_areas['area'] * utilisation_factors
    ratios = max_installed_capacity / installed_capacity
    technical_potential = annual_production * ratios

    # Create new dataset with cost and production volume
    # Add in country level data
    data_vars = {'WACC': waccs, 'technical_potential': technical_potential,
                 'Calculated_LCOE': levelised_costs, 'Uniform_LCOE': uniform_costs, 'country': country_grids['country']}
    coords = {'latitude': latitudes,
              'longitude': longitudes}
    supply_curve_ds = xr.Dataset(data_vars=data_vars, coords=coords)

    return supply_curve_ds





def produce_wacc_potential_curve(supply_ds, GDP_country_mapping, filename=None, graphmarking=None, title=None, xlim=None):

    def clean_results(dataframe):
        # Sort by levelised cost
        sorted_supply = dataframe.sort_values(by=['WACC'])

        # Remove rows that are empty
        cleaned_df = sorted_supply.dropna(axis='index')
        final_df = cleaned_df.copy()

        # Apply a threshold for locations with zero utilisation (if applicable)
        util_index_names = final_df[final_df['technical_potential'] == 0 ].index
        final_df.drop(util_index_names, inplace = True)

        return final_df

    # Convert the dataset to a dataframe
    supply_df = supply_ds.to_dataframe()

    # Extract the WACC and technical potential
    cleaned_results_df = clean_results(supply_df)

    # Plot the results
    sorted_lc = cleaned_results_df.sort_values(by=['WACC'], ascending=True)
    sorted_lc.loc[:, 'cumulative_potential'] = sorted_lc['technical_potential'].cumsum()
    rounded_df = sorted_lc.round({'WACC': 2})
    rounded_df = rounded_df.sort_values(by=['WACC'], ascending=True)
    fig, ax = plt.subplots(figsize=(20, 8))
    color_labels = {}
    cmap = mpl.colormaps['gnuplot_r']
    norm = mpl.colors.Normalize(vmin=0, vmax=50000)  # Normalize to the range of solar fractions




    # Iterate through each data point and create a bar with the specified width
    for index, row in rounded_df.iterrows():
        width = row['technical_potential'] / 1e+09  # Bar width
        height = row['WACC']  # Bar height
        country = row['country']
        cumulative_production = row['cumulative_potential'] / 1e+09  # Cumulative production

        # Get GDP per capita
        gdp_per_capita = GDP_country_mapping.loc[GDP_country_mapping['index'] == country, '2022'].values[0]
        color = cmap(norm(gdp_per_capita))

        # Plot a bar with the specified width, height, x-position, and color
        ax.bar(cumulative_production, height, width=-1 * width, align='edge', color=color)


    def thousands_format(x, pos):
        return f'{int(x):,}'

    # Set labels
    ax.set_xlim(0, xlim)
    ax.set_ylim(0, 25)
    ax.set_ylabel('WACC (%)', fontsize=20)
    ax.set_xlabel('Annual Electricity Potential (TWh/year)', fontsize=25)
    ax.set_title(title, fontsize=30)
    ax.xaxis.set_major_formatter(FuncFormatter(thousands_format))

    # Set the size of x and y-axis tick labels
    ax.tick_params(axis='x', labelsize=20)  # Adjust the labelsize as needed
    ax.tick_params(axis='y', labelsize=20)  # Adjust the labelsize as needed

    # Add color bar
    cbar = plt.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=cmap), ax=ax, ticks=[0, 5000, 10000, 15000, 20000, 25000, 30000, 35000, 40000, 450000,50000], format=',', extend="max", anchor=(0.25, 0.5))
    cbar.ax.yaxis.set_major_formatter(FuncFormatter(thousands_format))
    cbar.set_label('GDP per capita (USD, 2022)', fontsize=20)
    cbar.ax.tick_params(labelsize=15)

    # Get the LCOE plot
    lcoe_data = cleaned_results_df[['Calculated_LCOE', 'Uniform_LCOE', 'technical_potential']]
    sorted_lcoe = cleaned_results_df.sort_values(by=['Calculated_LCOE'], ascending=True).copy()
    sorted_lcoe.loc[:, 'cumulative_potential'] = sorted_lcoe['technical_potential'].cumsum()
    sorted_uniform_lcoe = cleaned_results_df.sort_values(by=['Uniform_LCOE'], ascending=True).copy()
    sorted_uniform_lcoe.loc[:, 'cumulative_potential'] = sorted_uniform_lcoe['technical_potential'].cumsum()


    # Plot second axis
    # Create a twin Y-axis on the same figure
    ax2 = ax.twinx()

    # Plot lines on the twin Y-axis (this axis is independent of the main y-axis)
    ax2.plot(sorted_lcoe['cumulative_potential']/1e+9, sorted_lcoe['Calculated_LCOE']*1000, color='blue', lw=2.5, label='LCOE under Country-level WACC', linestyle="--")
    ax2.plot(sorted_uniform_lcoe['cumulative_potential']/1e+9, sorted_uniform_lcoe['Uniform_LCOE']*1000, color='red', lw=2.5, label='LCOE under Uniform 7% WACC', linestyle="--")

    # Customize the second y-axis
    ax2.set_ylabel('Levelised Cost (USD/MWh)', fontsize=20)
    ax2.legend(loc='upper center', fontsize=20)
    ax2.tick_params(axis="y", labelsize=20)
    ax2.set_ylim(0, 250)

    if graphmarking is not None:
        ax.text(0.02, 0.94, graphmarking, transform=ax.transAxes, fontsize=20, fontweight='bold')

    if filename is not None:
        plt.savefig(filename + ".png", bbox_inches="tight")

    plt.show()

    return rounded_df


    
# Produce Supply Curve
plot_wacc_supply = input("Start Plotting Tech Potential - WACC? Yes/No")
if plot_wacc_supply == "Yes":

    import matplotlib as mpl
    from matplotlib.ticker import FuncFormatter

    solar = solar_results 
    wind = wind_results
    data = wacc_model.calculated_data

    land_cover = xr.open_dataset("./DATA/GlobalLandCover.nc")
    land_mapping = pd.read_csv("./DATA/LandUseCSV.csv")
    country_grids = xr.open_dataset("./DATA/country_grids.nc")
    country_grids['country'] = xr.where(np.isnan(country_grids['land']), country_grids['sea'], country_grids['land'])
    country_mapping = pd.read_csv("./DATA/country_mapping.csv")
    GDP = pd.read_csv("./DATA/GDPPerCapita.csv")[['Country code', '2022']]
    GDP_country_mapping = pd.merge(country_mapping, GDP, on="Country code", how="left")

    


    solar_supply_curve = get_supply_curves(land_cover, land_mapping, solar_results['Calculated_LCOE'], solar_results['Uniform_LCOE'], solar_results['electricity_production'], solar_results['Estimated_WACC'], "Solar", country_grids)
    solar_df = produce_wacc_potential_curve(solar_supply_curve, GDP_country_mapping, filename="SolarGlobalSupplyCurve", graphmarking="a", title="Solar", xlim=140000)

    wind_supply_curve = get_supply_curves(land_cover, land_mapping, wind_results['Calculated_LCOE'], wind_results['Uniform_LCOE'], wind_results['electricity_production'], wind_results['Estimated_WACC'], "Wind", country_grids)
    wind_df = produce_wacc_potential_curve(wind_supply_curve, GDP_country_mapping, filename="WindGlobalSupplyCurve", graphmarking="b", title="Wind", xlim=175000)

def plot_wacc_values(estimated_waccs, country_mapping, technology): 

    data = country_mapping
    storage_df = xr.zeros_like(data['land'])
    if technology == "Offshore Wind":
        storage_df = xr.zeros_like(data['sea'])
    storage_df = xr.where(storage_df == 0, np.nan, np.nan)
    for i in np.arange(1, 251, 1):
        # Extract WACC
        if technology == "Solar":
            wacc = estimated_waccs[estimated_waccs['index'] == i]['solar_pv_wacc'].values[0] 
        elif technology == "Onshore Wind":
            wacc = estimated_waccs[estimated_waccs['index'] == i]['onshore_wacc'].values[0] 
        elif technology == "Offshore Wind":
            wacc = estimated_waccs[estimated_waccs['index'] == i]['offshore_wacc'].values[0] 

        # Apply mapping
        storage_df = xr.where(data['land'] == i, wacc, storage_df)

    # Extracted data
    extracted_data = storage_df

    return extracted_data
        
# Create WACC visualisation
plot_wacc_values = input("Plot WACC visualisations? Yes/No")
if plot_wacc_values == "Yes":
                            
    country_geodata = wacc_model.geodata.reindex({"latitude":solar_results.latitude, "longitude":solar_results.longitude}, method="nearest")
    solar_plot_waccs = plot_wacc_values(wacc_model.country_wacc_mapping, country_geodata, "Solar")
    solar_plot_waccs = xr.where(np.isnan(solar_results['Calculated_LCOE']), np.nan, solar_plot_waccs)
    onshore_plot_waccs = plot_wacc_values(wacc_model.country_wacc_mapping, country_geodata, "Onshore Wind")
    onshore_plot_waccs = xr.where(np.isnan(solar_results['Calculated_LCOE']), np.nan, onshore_plot_waccs)
    offshore_plot_waccs = plot_wacc_values(wacc_model.country_wacc_mapping, country_geodata, "Offshore Wind")
    offshore_plot_waccs = xr.where(np.isnan(onshore_plot_waccs), np.nan, offshore_plot_waccs)

    wacc_model.plot_data_shading(solar_plot_waccs,solar_plot_waccs.latitude, solar_plot_waccs.longitude, tick_values = [0, 5, 10, 15, 20], title="Estimated\nWACC \n (%, real,\nafter tax)\n", cmap="YlOrRd", extend_set="neither", filename = output_folder + "Solar_WACC_2023", graphmarking="a")

    wacc_model.plot_data_shading(onshore_plot_waccs, onshore_plot_waccs.latitude, onshore_plot_waccs.longitude, tick_values = [0, 5, 10, 15, 20], title="Estimated\nWACC\n (%, real,\nafter tax)\n", cmap="YlGnBu", extend_set="neither", filename = output_folder + "Wind_WACC_2023", graphmarking="b")

    wacc_model.plot_data_shading(offshore_plot_waccs, offshore_plot_waccs.latitude, offshore_plot_waccs.longitude, tick_values = [0, 5, 10, 15, 20], title="Estimated\nWACC\n (%, real,\nafter tax)\n", cmap="YlGnBu", extend_set="neither", filename = output_folder + "Offshore_Wind_WACC_2023", graphmarking="c")
                                
                                
                                
def get_concessionality_v3(wacc_model, data, concessional_rate, technology):
    
    # Convert data in netcdf to pandas dataframe
    merged_dataset = xr.Dataset({
    "Required_WACC": data,
    "index": wacc_model.land_mapping
})
    working_dataframe = merged_dataset.to_dataframe().reset_index()
    
    # Import the existing costs of commercial debt, equity and the modelled debt share
    if technology == "Wind":
        financing_values = wacc_model.calculated_data[['Country code', 'index', 'Debt_Share_2023', 'Onshore_Wind_WACC_2023', 'Wind_Cost_Debt_2023', 'Wind_Cost_Equity_2023', 'Tax_Rate']].rename(columns={"Onshore_Wind_WACC_2023":"WACC_2023", "Wind_Cost_Debt_2023": "Debt_Cost_2023", "Wind_Cost_Equity_2023":"Equity_Cost_2023"})
    elif technology == "Solar":
        financing_values = wacc_model.calculated_data[['Country code', 'index', 'Debt_Share_2023', 'Solar_WACC_2023', 'Solar_Cost_Debt_2023', 'Solar_Cost_Equity_2023', 'Tax_Rate']].rename(columns={"Solar_WACC_2023":"WACC_2023", "Solar_Cost_Debt_2023": "Debt_Cost_2023", "Solar_Cost_Equity_2023":"Equity_Cost_2023"})
    financing_terms = pd.merge(working_dataframe, financing_values, how="left", on="index") 
    
    # Calculate debt-equity ratio
    financing_terms['Equity_Share_2023'] = (100 - financing_terms['Debt_Share_2023']) 
    financing_terms['Debt_Equity_Ratio'] =  financing_terms['Debt_Share_2023'] / financing_terms['Equity_Share_2023']
    
    # Set the cost of concessional financing 
    financing_terms['Concessional_Cost_2023'] = concessional_rate 
    
    
    # Calculate the share of concessional financing / commercial debt / commercial equity
    numerator =  (financing_terms['Debt_Equity_Ratio'] + 1) * financing_terms['Required_WACC'] - financing_terms['Debt_Cost_2023'] * financing_terms['Debt_Equity_Ratio'] * (1 - financing_terms['Tax_Rate']/100) - financing_terms['Equity_Cost_2023']
    denominator = ((financing_terms['Debt_Equity_Ratio'] + 1) * financing_terms['Concessional_Cost_2023'] * (1 - financing_terms['Tax_Rate']/100) - financing_terms['Equity_Cost_2023'] - financing_terms['Debt_Cost_2023'] * (1 - financing_terms['Tax_Rate']/100) * financing_terms['Debt_Equity_Ratio'])
    financing_terms['Concessional_Debt_Share'] = numerator / denominator
    financing_terms['Commercial_Equity_Share'] = (1 - financing_terms['Concessional_Debt_Share']) / (financing_terms['Debt_Equity_Ratio'] + 1) 
    financing_terms['Commercial_Debt_Share'] = 1 - financing_terms['Concessional_Debt_Share'] - financing_terms['Commercial_Equity_Share'] 
    
    # Calculate shares of final
    financing_terms['Equity_Contribution'] = financing_terms['Commercial_Equity_Share'] * (financing_terms['Equity_Cost_2023'])
    financing_terms['Debt_Contribution'] = financing_terms['Commercial_Debt_Share'] * (financing_terms['Debt_Cost_2023'] * (1 - financing_terms['Tax_Rate']/100) ) 
    financing_terms['Concessional_Contribution'] = financing_terms['Concessional_Debt_Share'] * financing_terms['Concessional_Cost_2023'] * (1 - financing_terms['Tax_Rate']/100)
    financing_terms['Concessionality'] = financing_terms['Debt_Cost_2023'] - financing_terms['Concessional_Cost_2023']
    
    # Create a check
    financing_terms['Total_Check'] =  financing_terms['Concessional_Debt_Share'] + financing_terms['Commercial_Debt_Share'] + financing_terms['Commercial_Equity_Share']
    financing_terms['WACC_Concessional'] =  financing_terms['Equity_Contribution'] + financing_terms['Debt_Contribution'] + financing_terms['Concessional_Contribution']
    
    # Address inequalities
    financing_terms['Concessional_Debt_Share'] = financing_terms['Concessional_Debt_Share'] * 100
    financing_terms.loc[financing_terms['Required_WACC'] == 999, "Concessional_Debt_Share"] = 999
    financing_terms.loc[financing_terms['Required_WACC'] == 111, "Concessional_Debt_Share"] = 111
    financing_terms.loc[financing_terms['Required_WACC'] < concessional_rate, "Concessional_Debt_Share"] = 999
    financing_terms.loc[financing_terms['Required_WACC'] < concessional_rate, "Commercial_Equity_Share"] = 999
    financing_terms.loc[financing_terms['Required_WACC'] < concessional_rate, "Commercial_Debt_Share"] = 999
    
    # Convert back to netcdf
    financing_terms = financing_terms.set_index(["latitude", "longitude"])
    processed_data = financing_terms.to_xarray()
    
    return financing_terms, processed_data    
    
    
concessional_wacc = input("Plot Concessional Debt Share Requirements? Yes/No")
if concessional_wacc == "Yes":
    wacc_concessional_solar = xr.where(solar_benchmark_results['Calculated_LCOE'] < solar_benchmark_results['Benchmark_LCOE'], 111, solar_benchmark_wacc)
    concessional_calcs, processed_data_solar_benchmark = get_concessionality_v3(wacc_model, wacc_concessional_solar, 1, "Solar")
    wacc_model.plot_data_shading(processed_data_solar_benchmark['Concessional_Debt_Share'], processed_data_solar_benchmark.latitude, processed_data_solar_benchmark.longitude, special_value = 999, hatch_label = "Above US$60/MWh\nwith 100% concessional \nfinancing", special_value_2 = 111, hatch_label_2="Below US$60/MWh\nwithout concessional \nfinancing", tick_values = [0, 25, 50, 75, 100], cmap="YlOrRd", title="Required\nShare Of\nConcessional\nFinancing (%)\n", filename="CONC_FINANCE_SOLAR", graphmarking="a", extend_set="neither")
    print(np.nanmean(xr.where((processed_data_solar_benchmark['Concessional_Debt_Share'] == 111) | (processed_data_solar_benchmark['Concessional_Debt_Share'] ==999), np.nan, processed_data_solar_benchmark['Concessional_Debt_Share'])))
    print(np.nanmean(xr.where((processed_data_solar['Concessional_Debt_Share'] == 111) | (processed_data_solar_benchmark['Concessional_Debt_Share'] ==999), np.nan, processed_data_solar_benchmark['Concessional_Debt_Share'])))


    wacc_concessional_wind = xr.where(wind_benchmark_results['Calculated_LCOE'] < wind_benchmark_results['Benchmark_LCOE'], 111, wind_benchmark_wacc)
    concessional_calcs_v1, processed_data_wind_benchmark = get_concessionality_v3(wacc_model, wacc_concessional_wind, 1, "Wind")
    wacc_model.plot_data_shading(processed_data_wind_benchmark['Concessional_Debt_Share'].drop_sel(latitude=0), processed_data_wind_benchmark.drop_sel(latitude=0).latitude, processed_data_wind_benchmark.longitude, special_value = 999, hatch_label = "Above US$50/MWh\nwith 100% concessional \nfinancing", special_value_2 = 111, hatch_label_2="Below US$50/MWh\nwithout concessional \nfinancing", tick_values = [0, 25, 50, 75, 100], cmap="YlGnBu", title="Required\nShare Of\nConcessional\nFinancing (%)\n", filename="CONC_FINANCE_WIND", graphmarking="b", extend_set="neither")
    print(np.nanmean(xr.where((processed_data_wind_benchmark['Concessional_Debt_Share'] == 111) | (processed_data_wind_benchmark['Concessional_Debt_Share'] ==999), np.nan, processed_data_wind_benchmark['Concessional_Debt_Share'])))
    print(np.nanmean(xr.where((processed_data_wind_benchmark['Concessional_Debt_Share'] == 111) | (processed_data_wind_benchmark['Concessional_Debt_Share'] ==999), np.nan, processed_data_wind_benchmark['Concessional_Debt_Share'])))
    

